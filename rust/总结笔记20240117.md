### 变量绑定与解构

1. 定义常量时必须声明类型，并且常量名字必须是大写字母，字母之间用_分开

	```rust
	const NUMBER : i32 = 3;
	```




### 基本类型

1. 变量类型声明方式

	- 编译器自动推导，给予变量类型；

	- 变量：变量类型=数值；

	- 变量=数值变量类型；

		(补充：要声明一个值的类型可在值后用_+类型)

2. 在rust中，未声明时默认`i32`和`f64`

3. 只有同类型的才能进行运算

4. rust中应遵循以下准则：

	- 避免在浮点数上测试相等性
	- 当结果在数学上可能存在未定义时，例如负数取平方根，需要格外小心,对于这种情况可以使用is_nan()来判断一个数值是否是NaN（not a number）,eg:

	```rust
	fn main() {
	    let x = (-42.0_f32).sqrt();
	    //x为一个负数取平方根
	    if x.is_nan() {
	        println!("未定义的数学行为")
	    }
	}
	//运行结果为：未定义的数学行为
	```

5. 序列

	- 1..5 表示生成1到4的连续数字，不包含5

	- 1..=5 表示生成从1到5的连续数字，包含5

		其还可以用于生成字符类型序列,常用于循环

		```rust
		for i in 'a'..='z' {
		    println!("{}",i);
		}
		```

		

5. Rust 是一种强类型语言，不允许隐式类型转换

	```rust
	fn main() {
	    let x: i32 = 5;
	    let mut y: u32 = 5;
	
	    y = x;
	    //此处是错误的可改为 y=x as u32
	}
	```

	

6. `i8::MAX` 是 Rust 标准库中 `i8` 类型的最大值常量。它表示有符号 8 位整数类型（即 `i8`）的最大值，也就是 127。这个值的二进制表示为 `0111 1111`，其中最高位为符号位，为 0，表示正数。



7. 在 Rust 中，`assert!` 是一个宏，用于进行断言检查。它接受一个布尔表达式作为参数，并在表达式为 false 的情况下触发断言失败。`assert!` 宏的使用方法如下：

```rust
rustCopy Codefn main() {
    let value = 42;
    assert!(value > 0, "Value must be greater than 0");
}
```

在上面的例子中，我们对变量 `value` 进行断言检查，要求其大于 0。如果断言失败，则会打印出给定的错误消息 `"Value must be greater than 0"` 并终止程序的执行。

`assert!` 宏也支持使用格式化字符串来输出更详细的错误消息：

```rust 
rustCopy Codefn main() {
    let expected = 10;
    let actual = 5 + 5;
    assert!(expected == actual,"Expected {}, but got {}", expected, actual);
}
```

在这个例子中，我们对变量 `expected` 和 `actual` 进行断言检查，要求它们相等。如果断言失败，将打印出类似于 `"Expected 10, but got 15"` 的错误消息。



8. 
	- `i8`: 有符号 8 位整数，范围是 -128 到 127。
	- `i16`: 有符号 16 位整数，范围是 -32768 到 32767。
	- `i32`: 有符号 32 位整数，范围是 -2147483648 到 2147483647。
	- `i64`: 有符号 64 位整数，范围是 -9223372036854775808 到 9223372036854775807。
	- `f32`:大概小数点后7位。

	

9. `EPSILON` 是 `f64`（或 `f32`）类型的一个常量，它表示浮点数所能表示的最小精度。具体来说，它是一个非常小的浮点数，用于比较两个浮点数是否足够接近。需要注意的是，`EPSILON` 常量和浮点数类型有关，因此 `f32::EPSILON` 和 `f64::EPSILON` 的值是不同的。



10. 在 Rust 中，`abs()` 是 `f64`（或 `f32`）类型的一个方法，它的作用是将浮点数取绝对值并返回。需要注意的是，`abs()` 方法只适用于浮点数类型，对于整数类型，可以使用 `i32.abs()` 或 `i64.abs()` 等相应的整数方法来获取绝对值。

```rust 
fn main() {
 assert(f64::abs(0.1+0.20.3<f64::EPSILON);
}
```

11. Range{ start: 1, end: 5 }表示[1,5);

RangeInclusive::new(1, 5)表示[1,5];



##### 字符、布尔（bool）、单元类型

1. Rust 的字符只能用 `''` 来表示， `""` 是留给字符串的。

2. 字符类型是占用 4 个字节；布尔值占用内存的大小为 1个字节；单元类型占用的内存大小为0字节。

3. 在rust中一个函数若要返回某种类型的值，则在函数名后面用` ->(类型)`表示，eg：

	```rust
	fn implicitly_ret_unit()->(i32,i32) {
	    println!("I will return a ()");
	    (3,2)//返回一个元组，注意不加分号
	}//在函数中返回值虽未加；最后也不需要加；
	```

	

##### 语句和表达式

1. 语句是完成一个具体操作，不返回值所以不能用语句给变量赋值，eg：

	```rust
	let b = (let a = 8);//这是不对的
	```

2. 能返回值就是表达式，且表达式不能以分号结尾，加上分号就会变成语句，再也不会返回值，==不带分号的不一定是表达式==，最后，表达式如果不返回值，就会隐式地返回一个`()`

```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // 或者写成一行
    let z = if x % 2 == 1 { "odd" } else { "even" };
}//无返回值，则返回（）
```

```rust
fn main() {
   let v = {
       let mut x = 1;
       x += 2
   };//这里就不对，因为x+=2不会返回值，是语句

   assert_eq!(v, 3);
}
```



##### 函数要点

1. 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可。

2. 每个函数参数都需要标注类型。

3. 在rust中通常最后用表达式返回值，也可以用return==提前返回值==。

4. 在 Rust 中，如果你在函数的最后使用 `return` 关键字来返回值，编译器会发出警告。这是因为在 Rust 中，函数的最后一个表达式的结果将被隐式地作为函数的返回值返回给调用者，不需要显式地使用 `return`。

	如果你使用 `return` 来返回值，如下所示：

	```rust
	fn add(a: i32, b: i32) -> i32 {
	    return a + b; // 这里使用了 return
	}
	```

	虽然这个代码可以正常工作，但是编译器会给出一个警告提示，因为这种使用 `return` 的方式在 Rust 中并不常见，并且增加了冗余的代码。==因此，在 Rust 中，通常不需要使用 `return` 关键字来返回函数的值。==
