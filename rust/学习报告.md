### 变量绑定与解构

1. 定义常量时必须声明类型，并且常量名字必须是大写字母，字母之间用_分开

	```rust
	const NUMBER : i32 = 3;
	```




### 基本类型

1. 变量类型声明方式

	- 编译器自动推导，给予变量类型；

	- 变量：变量类型=数值；

	- 变量=数值变量类型；

		(补充：要声明一个值的类型可在值后用_+类型)

2. 在rust中，未声明时默认`i32`和`f64`

3. 只有同类型的才能进行运算

4. rust中应遵循以下准则：

	- 避免在浮点数上测试相等性
	- 当结果在数学上可能存在未定义时，例如负数取平方根，需要格外小心,对于这种情况可以使用is_nan()来判断一个数值是否是NaN（not a number）,eg:

	```rust
	fn main() {
	    let x = (-42.0_f32).sqrt();
	    //x为一个负数取平方根
	    if x.is_nan() {
	        println!("未定义的数学行为")
	    }
	}
	//运行结果为：未定义的数学行为
	```

5. 序列

	- 1..5 表示生成1到4的连续数字，不包含5

	- 1..=5 表示生成从1到5的连续数字，包含5

		其还可以用于生成字符类型序列,常用于循环

		```rust
		for i in 'a'..='z' {
		    println!("{}",i);
		}
		```

		

5. Rust 是一种强类型语言，不允许隐式类型转换

	```rust
	fn main() {
	    let x: i32 = 5;
	    let mut y: u32 = 5;
	
	    y = x;
	    //此处是错误的可改为 y=x as u32
	}
	```

	

6. `i8::MAX` 是 Rust 标准库中 `i8` 类型的最大值常量。它表示有符号 8 位整数类型（即 `i8`）的最大值，也就是 127。这个值的二进制表示为 `0111 1111`，其中最高位为符号位，为 0，表示正数。



7. 在 Rust 中，`assert!` 是一个宏，用于进行断言检查。它接受一个布尔表达式作为参数，并在表达式为 false 的情况下触发断言失败。`assert!` 宏的使用方法如下：

```rust
rustCopy Codefn main() {
    let value = 42;
    assert!(value > 0, "Value must be greater than 0");
}
```

在上面的例子中，我们对变量 `value` 进行断言检查，要求其大于 0。如果断言失败，则会打印出给定的错误消息 `"Value must be greater than 0"` 并终止程序的执行。

`assert!` 宏也支持使用格式化字符串来输出更详细的错误消息：

```rust 
rustCopy Codefn main() {
    let expected = 10;
    let actual = 5 + 5;
    assert!(expected == actual,"Expected {}, but got {}", expected, actual);
}
```

在这个例子中，我们对变量 `expected` 和 `actual` 进行断言检查，要求它们相等。如果断言失败，将打印出类似于 `"Expected 10, but got 15"` 的错误消息。



8. 
	- `i8`: 有符号 8 位整数，范围是 -128 到 127。
	- `i16`: 有符号 16 位整数，范围是 -32768 到 32767。
	- `i32`: 有符号 32 位整数，范围是 -2147483648 到 2147483647。
	- `i64`: 有符号 64 位整数，范围是 -9223372036854775808 到 9223372036854775807。
	- `f32`:大概小数点后7位。

	

9. `EPSILON` 是 `f64`（或 `f32`）类型的一个常量，它表示浮点数所能表示的最小精度。具体来说，它是一个非常小的浮点数，用于比较两个浮点数是否足够接近。需要注意的是，`EPSILON` 常量和浮点数类型有关，因此 `f32::EPSILON` 和 `f64::EPSILON` 的值是不同的。



10. 在 Rust 中，`abs()` 是 `f64`（或 `f32`）类型的一个方法，它的作用是将浮点数取绝对值并返回。需要注意的是，`abs()` 方法只适用于浮点数类型，对于整数类型，可以使用 `i32.abs()` 或 `i64.abs()` 等相应的整数方法来获取绝对值。

```rust 
fn main() {
 assert(f64::abs(0.1+0.20.3<f64::EPSILON);
}
```

11. Range{ start: 1, end: 5 }表示[1,5);

RangeInclusive::new(1, 5)表示[1,5];
